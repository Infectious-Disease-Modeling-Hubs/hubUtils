#' Connect to a Modeling Hub
#'
#'
#' @param hub_path Path to the Modeling Hub directory.
#' @param hubmeta_path Path to a hubmeta file. The default (`NULL`) expects a file
#'   in the root of the directory given in `hub_path` named `hubmeta` and having
#'   an accepted file format (see `hubmeta_format`). Use this argument if the
#'   hubmeta file is in a non-default location or has a non-default file name and
#'   include the file extension in the path.
#' @param hubmeta_format The file extension of the hubmeta file. One of `"json"`,
#'   `"yaml"` or `"yml"`. Defaults to `"json"` and ignored when `hubmeta_path` is
#'   provided.
#' @return an S3 object of class `<hub-connection>` containing metadata about the
#'   modeling hub. This object is used to communicate with the Modelling Hub when
#'   extracting or submitting data.
#' @export
#'
#' @examples
#' # Simple forecasting Hub example
#' hub_path <- system.file("hub_1", package = "hubUtils")
#' connect_hub(hub_path)
#' # Scenario Hub example
#' scnr_path <- system.file("scnr_hub_1", package = "hubUtils")
#' connect_hub(hub_path)
connect_hub <- function(hub_path, hubmeta_path = NULL,
                        hubmeta_format = c("json", "yaml", "yml")) {

    hubmeta_format <- rlang::arg_match(hubmeta_format)

    if (is.null(hubmeta_path)) {
        hubmeta_path <- fs::path(
            hub_path,
            "hubmeta",
            ext = hubmeta_format
            )
    }

    hubmeta <- read_hubmeta(hubmeta_path)

    hubmeta[["hubmeta_path"]] <- hubmeta_path
    hubmeta[["hub_path"]] <- hub_path

    new_hub_connection(hubmeta)

}

# INTERNAL ----

#' Create new hub connection S3 class object
#'
#' Internal function for create a new hub connection S3 class object
#' @param x A metadata list generated by [read_hubmeta()].
#'
#' @return A hub connection S3 class object.
#' @noRd
new_hub_connection <- function(x) {
    stopifnot(is.list(x))

    x <- assign_hc_attrs(x)

    class(x) <- "hub_connection"

    x
}


#' Assign high level hub metadata as attributes.
#'
#' @param x A metadata list generated by [read_hubmeta()].
#'
#' @return
#'   A metadata list with `task_ids` names and `round_ids` assigned to
#'   attributes `task_id_names` and `round_ids` respectively.
#'
#'   Where the metadata list contains round specific metadata
#'   elements, a named list containing `task_ids` names per round is assigned to
#'   `task_id_names` and a character vector of the names of elements containing
#'   round specific metadata is assigned to `round_ids`.
#'
#'   Where metadata are shared between rounds
#'   (indicated by the name of the first element of the metadata list being
#'   `"round_id_from_variable"`), a single character vector of task_ids names
#'   is assigned to attribute `task_id_names` and the value of element
#'   `"round_id_from_variable"` is assigned to attribute `round_ids`.
#'
#'   Where a `hubmeta_path` and/or `hub_path` elements are present in the metadata
#'   list, they are removed from the list and assigned to attributes `hubmeta_path`
#'   `hub_path` respectively.
#' @noRd
assign_hc_attrs <- function(x) {

    # if assigned, move hubmeta_path & hub_path to attributes to maintain
    # original hubmeta structure
    if(!is.null(x$hubmeta_path)){
        attr(x, "hubmeta_path") <- x$hubmeta_path
        x$hubmeta_path <- NULL
    }

    if(!is.null(x$hub_path)){
        attr(x, "hub_path") <- x$hub_path
        x$hub_path <- NULL
    }

    if (names(x)[1] == "round_id_from_variable") {

        task_id_names <- purrr::pluck(
            x,
            "round_id_from_variable",
            "model_tasks",
            1,
            "task_ids"
        ) %>%
            names()

        round_ids <- x[["round_id_from_variable"]][["round_id_variable"]]
        task_ids_by_round <- FALSE

    } else {

        # TODO - confirm that hub metadata that vary by round will
        # contain 'round' in the name
        task_id_names <- x[grepl("round", names(x))] %>%
            purrr::map(
                ~purrr::pluck(
                    .x,
                    "model_tasks",
                    1,
                    "task_ids"
                ) %>%
                    names()
            )
        round_ids <- names(task_id_names)

        task_ids_by_round <- TRUE
    }


    if (is.null(task_id_names)) {
        cli::cli_abort(
            "Cannot parse {.var task_ids} names from hubmeta file
                {.file { attr(x, 'hubmeta_path') }}"
        )
    }
    attr(x, "task_id_names") <- task_id_names

    if (is.null(round_ids)) {
        cli::cli_abort(
            "Cannot parse {.var round_ids} from hubmeta file
                {.file { attr(x, 'hubmeta_path') }}"
        )
    }

    attr(x, "round_ids") <- round_ids

    attr(x, "task_ids_by_round") <- task_ids_by_round


    return(x)
}


## EXPERIMENTAL Class Specific PRINT METHOD
# #' @export
print.hub_connection <- function(x, verbose = FALSE) {

    cli::cli_h1("{.cls hub_connection}")
    cli::cli_bullets(c(
        "i" = "Connected to Hub at  {.file { attr(x, 'hub_path') }}",
        "i" = "Connection configured using {.field hubmeta} file
        {.file { attr(x, 'hub_path') }}"
    ))

    if (verbose) {
        print.default(x)
    }

    invisible(x)
}
